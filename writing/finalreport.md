# Final Report

## Date: 1 Dec 2018
## Group Names: Haeley Griffin, Xingbang Liu, Jordan Wilson, Sweta Rauniyar

### Introduction
## Include central thesis in the introduction

### Algorithms
We decided to analyze and compare the different kinds of algorithms including Breadth-First Search, Depth-First Search, Greedy Search,, and A* Search Algorithm. The motive of our project was to find the shortest path and hence comparing them based on their functioning and eventually the drawbacks gave us a keen idea about which would be the best option for us. We researched in deeper for each of the respective algorithm to understand them in a descriptive manner.

#### Breadth-First Search
Breadth-First Search Algorithm is one of the widely used traversal technique for searching through the algorithm. In this algorithm, we start with the source node, also called the root node or the tree node. There are nodes connected to the source node, known as the neighbor nodes. These neighbor nodes are explored and then we move on to the next level of the neighbor nodes, further repeating the process all over again until we get to the end of the graph. What's happening in this algorithm is that we move through the entire graph to get to our destination and we do find the shortest path. However, since we are bound to traverse through the entire graph, this process consumes a lot of time and uses a lot of memory space. Hence, we decided that this was not a reliable option for us to work with for our project.

#### Depth-First Search
Depth-First Search is a recursive algorithm. This searching algorithm works by traversing through each node until it reach an end point and then has to back track up the branch until it reaches a node that is not marked as visited, it will then repeat this until it goes through the whole set of nodes. This algorithm can also be implemented as a stack. You select a node that will become the starting node and then all of the other nodes go into the stack. Then you pick the top node which you mark as visited. You then keep completing this till you go through the whole stack. If you do not mark the node as visited than it could create an infinite loop. There are disadvantages to this searching algorithm though.One of those is that it may go down the first branch forever. Another drawback would be that there is no guarantee for a minimum solution. The last drawback is that it may not even find solution .at all. With these draw back this is not the most efficient algorithm.  After drawing these conclusions about depth-first we wanted to continue in our search for the most efficient searching algorithm.

#### Greedy Search

A greedy algorithm is a unique type of algorithm we researched while working on this project. This algorithm is unique because for starters it isn't an actual algorithm at all. It is a type of technique used to run through possible situations at choose what it deems as the best. A greedy algorithm will always pick the highest value in a situation. Also, a greedy algorithm is quite easy to use. When you are on a time-crunch, it is a good and easy way to simplify a problem to come up with a solution. A downside to making greedy algorithm are that they donâ€™t always focus on the entirety of what you are trying to figure out. Greedy algorithms will always choose what is best in a situation but this is not always efficient. With this issue, it is much harder to find and figure out problems that may be inside the code. It is also important to note that most greedy algorithms are not actually correct, they are just a way of simplifying a problem. The solution a greedy algorithm may come up with is not always correct. The greedy algorithm just chooses what it thinks is best, not actually what is best. As we can see, this algorithm may not be the best algorithm when it comes to problem solving.

#### A* Algorithm

### A* Algorithm Application

### Conclusion
